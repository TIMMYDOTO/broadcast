// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rpc/_rpc_default.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Bb_Mobile_OddinTreeWs_EmptyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Bb_Mobile_OddinTreeWs_DefaultResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: Int32 = 0

  var status: String = String()

  var error: Bb_Mobile_OddinTreeWs_Error {
    get {return _error ?? Bb_Mobile_OddinTreeWs_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Bb_Mobile_OddinTreeWs_Error? = nil
}

struct Bb_Mobile_OddinTreeWs_MainRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Bb_Mobile_OddinTreeWs_MainRequest.OneOf_Type? = nil

  var ping: Bb_Mobile_OddinTreeWs_PingRequest {
    get {
      if case .ping(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_PingRequest()
    }
    set {type = .ping(newValue)}
  }

  var setSettings: Bb_Mobile_OddinTreeWs_SetSettingsRequest {
    get {
      if case .setSettings(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_SetSettingsRequest()
    }
    set {type = .setSettings(newValue)}
  }

  var unsubscribe: Bb_Mobile_OddinTreeWs_UnsubscribeRequest {
    get {
      if case .unsubscribe(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_UnsubscribeRequest()
    }
    set {type = .unsubscribe(newValue)}
  }

  var subscribeState: Bb_Mobile_OddinTreeWs_SubscribeStateRequest {
    get {
      if case .subscribeState(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_SubscribeStateRequest()
    }
    set {type = .subscribeState(newValue)}
  }

  var unsubscribeState: Bb_Mobile_OddinTreeWs_UnsubscribeStateRequest {
    get {
      if case .unsubscribeState(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_UnsubscribeStateRequest()
    }
    set {type = .unsubscribeState(newValue)}
  }

  var subscribeSport: Bb_Mobile_OddinTreeWs_SubscribeSportRequest {
    get {
      if case .subscribeSport(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_SubscribeSportRequest()
    }
    set {type = .subscribeSport(newValue)}
  }

  var unsubscribeSport: Bb_Mobile_OddinTreeWs_UnsubscribeSportRequest {
    get {
      if case .unsubscribeSport(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_UnsubscribeSportRequest()
    }
    set {type = .unsubscribeSport(newValue)}
  }

  var subscribeTournament: Bb_Mobile_OddinTreeWs_SubscribeTournamentRequest {
    get {
      if case .subscribeTournament(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_SubscribeTournamentRequest()
    }
    set {type = .subscribeTournament(newValue)}
  }

  var unsubscribeTournament: Bb_Mobile_OddinTreeWs_UnsubscribeTournamentRequest {
    get {
      if case .unsubscribeTournament(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_UnsubscribeTournamentRequest()
    }
    set {type = .unsubscribeTournament(newValue)}
  }

  var subscribeFullTournament: Bb_Mobile_OddinTreeWs_SubscribeFullTournamentRequest {
    get {
      if case .subscribeFullTournament(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_SubscribeFullTournamentRequest()
    }
    set {type = .subscribeFullTournament(newValue)}
  }

  var unsubscribeFullTournament: Bb_Mobile_OddinTreeWs_UnsubscribeFullTournamentRequest {
    get {
      if case .unsubscribeFullTournament(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_UnsubscribeFullTournamentRequest()
    }
    set {type = .unsubscribeFullTournament(newValue)}
  }

  var subscribeMatch: Bb_Mobile_OddinTreeWs_SubscribeMatchRequest {
    get {
      if case .subscribeMatch(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_SubscribeMatchRequest()
    }
    set {type = .subscribeMatch(newValue)}
  }

  var unsubscribeMatch: Bb_Mobile_OddinTreeWs_UnsubscribeMatchRequest {
    get {
      if case .unsubscribeMatch(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_UnsubscribeMatchRequest()
    }
    set {type = .unsubscribeMatch(newValue)}
  }

  var subscribeFullMatch: Bb_Mobile_OddinTreeWs_SubscribeFullMatchRequest {
    get {
      if case .subscribeFullMatch(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_SubscribeFullMatchRequest()
    }
    set {type = .subscribeFullMatch(newValue)}
  }

  var unsubscribeFullMatch: Bb_Mobile_OddinTreeWs_UnsubscribeFullMatchRequest {
    get {
      if case .unsubscribeFullMatch(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_UnsubscribeFullMatchRequest()
    }
    set {type = .unsubscribeFullMatch(newValue)}
  }

  var subscribeStake: Bb_Mobile_OddinTreeWs_SubscribeStakeRequest {
    get {
      if case .subscribeStake(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_SubscribeStakeRequest()
    }
    set {type = .subscribeStake(newValue)}
  }

  var unsubscribeStake: Bb_Mobile_OddinTreeWs_UnsubscribeStakeRequest {
    get {
      if case .unsubscribeStake(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_UnsubscribeStakeRequest()
    }
    set {type = .unsubscribeStake(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable {
    case ping(Bb_Mobile_OddinTreeWs_PingRequest)
    case setSettings(Bb_Mobile_OddinTreeWs_SetSettingsRequest)
    case unsubscribe(Bb_Mobile_OddinTreeWs_UnsubscribeRequest)
    case subscribeState(Bb_Mobile_OddinTreeWs_SubscribeStateRequest)
    case unsubscribeState(Bb_Mobile_OddinTreeWs_UnsubscribeStateRequest)
    case subscribeSport(Bb_Mobile_OddinTreeWs_SubscribeSportRequest)
    case unsubscribeSport(Bb_Mobile_OddinTreeWs_UnsubscribeSportRequest)
    case subscribeTournament(Bb_Mobile_OddinTreeWs_SubscribeTournamentRequest)
    case unsubscribeTournament(Bb_Mobile_OddinTreeWs_UnsubscribeTournamentRequest)
    case subscribeFullTournament(Bb_Mobile_OddinTreeWs_SubscribeFullTournamentRequest)
    case unsubscribeFullTournament(Bb_Mobile_OddinTreeWs_UnsubscribeFullTournamentRequest)
    case subscribeMatch(Bb_Mobile_OddinTreeWs_SubscribeMatchRequest)
    case unsubscribeMatch(Bb_Mobile_OddinTreeWs_UnsubscribeMatchRequest)
    case subscribeFullMatch(Bb_Mobile_OddinTreeWs_SubscribeFullMatchRequest)
    case unsubscribeFullMatch(Bb_Mobile_OddinTreeWs_UnsubscribeFullMatchRequest)
    case subscribeStake(Bb_Mobile_OddinTreeWs_SubscribeStakeRequest)
    case unsubscribeStake(Bb_Mobile_OddinTreeWs_UnsubscribeStakeRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Bb_Mobile_OddinTreeWs_MainRequest.OneOf_Type, rhs: Bb_Mobile_OddinTreeWs_MainRequest.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setSettings, .setSettings): return {
        guard case .setSettings(let l) = lhs, case .setSettings(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsubscribe, .unsubscribe): return {
        guard case .unsubscribe(let l) = lhs, case .unsubscribe(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeState, .subscribeState): return {
        guard case .subscribeState(let l) = lhs, case .subscribeState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsubscribeState, .unsubscribeState): return {
        guard case .unsubscribeState(let l) = lhs, case .unsubscribeState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeSport, .subscribeSport): return {
        guard case .subscribeSport(let l) = lhs, case .subscribeSport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsubscribeSport, .unsubscribeSport): return {
        guard case .unsubscribeSport(let l) = lhs, case .unsubscribeSport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeTournament, .subscribeTournament): return {
        guard case .subscribeTournament(let l) = lhs, case .subscribeTournament(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsubscribeTournament, .unsubscribeTournament): return {
        guard case .unsubscribeTournament(let l) = lhs, case .unsubscribeTournament(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeFullTournament, .subscribeFullTournament): return {
        guard case .subscribeFullTournament(let l) = lhs, case .subscribeFullTournament(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsubscribeFullTournament, .unsubscribeFullTournament): return {
        guard case .unsubscribeFullTournament(let l) = lhs, case .unsubscribeFullTournament(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeMatch, .subscribeMatch): return {
        guard case .subscribeMatch(let l) = lhs, case .subscribeMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsubscribeMatch, .unsubscribeMatch): return {
        guard case .unsubscribeMatch(let l) = lhs, case .unsubscribeMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeFullMatch, .subscribeFullMatch): return {
        guard case .subscribeFullMatch(let l) = lhs, case .subscribeFullMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsubscribeFullMatch, .unsubscribeFullMatch): return {
        guard case .unsubscribeFullMatch(let l) = lhs, case .unsubscribeFullMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeStake, .subscribeStake): return {
        guard case .subscribeStake(let l) = lhs, case .subscribeStake(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsubscribeStake, .unsubscribeStake): return {
        guard case .unsubscribeStake(let l) = lhs, case .unsubscribeStake(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Bb_Mobile_OddinTreeWs_MainResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Bb_Mobile_OddinTreeWs_MainResponse.OneOf_Type? = nil

  var error: Bb_Mobile_OddinTreeWs_DefaultResponse {
    get {
      if case .error(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_DefaultResponse()
    }
    set {type = .error(newValue)}
  }

  var ping: Bb_Mobile_OddinTreeWs_PingResponse {
    get {
      if case .ping(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_PingResponse()
    }
    set {type = .ping(newValue)}
  }

  var setSettings: Bb_Mobile_OddinTreeWs_SetSettingsResponse {
    get {
      if case .setSettings(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_SetSettingsResponse()
    }
    set {type = .setSettings(newValue)}
  }

  var unsubscribe: Bb_Mobile_OddinTreeWs_UnsubscribeResponse {
    get {
      if case .unsubscribe(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_UnsubscribeResponse()
    }
    set {type = .unsubscribe(newValue)}
  }

  var subscribeState: Bb_Mobile_OddinTreeWs_SubscribeStateResponse {
    get {
      if case .subscribeState(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_SubscribeStateResponse()
    }
    set {type = .subscribeState(newValue)}
  }

  var unsubscribeState: Bb_Mobile_OddinTreeWs_UnsubscribeStateRequest {
    get {
      if case .unsubscribeState(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_UnsubscribeStateRequest()
    }
    set {type = .unsubscribeState(newValue)}
  }

  var subscribeSport: Bb_Mobile_OddinTreeWs_SubscribeSportResponse {
    get {
      if case .subscribeSport(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_SubscribeSportResponse()
    }
    set {type = .subscribeSport(newValue)}
  }

  var unsubscribeSport: Bb_Mobile_OddinTreeWs_UnsubscribeSportResponse {
    get {
      if case .unsubscribeSport(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_UnsubscribeSportResponse()
    }
    set {type = .unsubscribeSport(newValue)}
  }

  var subscribeTournament: Bb_Mobile_OddinTreeWs_SubscribeTournamentResponse {
    get {
      if case .subscribeTournament(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_SubscribeTournamentResponse()
    }
    set {type = .subscribeTournament(newValue)}
  }

  var unsubscribeTournament: Bb_Mobile_OddinTreeWs_UnsubscribeTournamentResponse {
    get {
      if case .unsubscribeTournament(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_UnsubscribeTournamentResponse()
    }
    set {type = .unsubscribeTournament(newValue)}
  }

  var subscribeFullTournament: Bb_Mobile_OddinTreeWs_SubscribeFullTournamentResponse {
    get {
      if case .subscribeFullTournament(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_SubscribeFullTournamentResponse()
    }
    set {type = .subscribeFullTournament(newValue)}
  }

  var unsubscribeFullTournament: Bb_Mobile_OddinTreeWs_UnsubscribeFullTournamentResponse {
    get {
      if case .unsubscribeFullTournament(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_UnsubscribeFullTournamentResponse()
    }
    set {type = .unsubscribeFullTournament(newValue)}
  }

  var subscribeMatch: Bb_Mobile_OddinTreeWs_SubscribeMatchResponse {
    get {
      if case .subscribeMatch(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_SubscribeMatchResponse()
    }
    set {type = .subscribeMatch(newValue)}
  }

  var unsubscribeMatch: Bb_Mobile_OddinTreeWs_UnsubscribeMatchResponse {
    get {
      if case .unsubscribeMatch(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_UnsubscribeMatchResponse()
    }
    set {type = .unsubscribeMatch(newValue)}
  }

  var subscribeFullMatch: Bb_Mobile_OddinTreeWs_SubscribeFullMatchResponse {
    get {
      if case .subscribeFullMatch(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_SubscribeFullMatchResponse()
    }
    set {type = .subscribeFullMatch(newValue)}
  }

  var unsubscribeFullMatch: Bb_Mobile_OddinTreeWs_UnsubscribeFullMatchResponse {
    get {
      if case .unsubscribeFullMatch(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_UnsubscribeFullMatchResponse()
    }
    set {type = .unsubscribeFullMatch(newValue)}
  }

  var subscribeStake: Bb_Mobile_OddinTreeWs_SubscribeStakeResponse {
    get {
      if case .subscribeStake(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_SubscribeStakeResponse()
    }
    set {type = .subscribeStake(newValue)}
  }

  var unsubscribeStake: Bb_Mobile_OddinTreeWs_UnsubscribeStakeResponse {
    get {
      if case .unsubscribeStake(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_UnsubscribeStakeResponse()
    }
    set {type = .unsubscribeStake(newValue)}
  }

  var stateAwait: Bb_Mobile_OddinTreeWs_StateAwaitResponse {
    get {
      if case .stateAwait(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_StateAwaitResponse()
    }
    set {type = .stateAwait(newValue)}
  }

  var stateReady: Bb_Mobile_OddinTreeWs_StateReadyResponse {
    get {
      if case .stateReady(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_StateReadyResponse()
    }
    set {type = .stateReady(newValue)}
  }

  var sport: Bb_Mobile_OddinTreeWs_SportResponse {
    get {
      if case .sport(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_SportResponse()
    }
    set {type = .sport(newValue)}
  }

  var tournament: Bb_Mobile_OddinTreeWs_TournamentResponse {
    get {
      if case .tournament(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_TournamentResponse()
    }
    set {type = .tournament(newValue)}
  }

  var match: Bb_Mobile_OddinTreeWs_MatchResponse {
    get {
      if case .match(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_MatchResponse()
    }
    set {type = .match(newValue)}
  }

  var fullMatch: Bb_Mobile_OddinTreeWs_FullMatchResponse {
    get {
      if case .fullMatch(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_FullMatchResponse()
    }
    set {type = .fullMatch(newValue)}
  }

  var stake: Bb_Mobile_OddinTreeWs_StakeResponse {
    get {
      if case .stake(let v)? = type {return v}
      return Bb_Mobile_OddinTreeWs_StakeResponse()
    }
    set {type = .stake(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable {
    case error(Bb_Mobile_OddinTreeWs_DefaultResponse)
    case ping(Bb_Mobile_OddinTreeWs_PingResponse)
    case setSettings(Bb_Mobile_OddinTreeWs_SetSettingsResponse)
    case unsubscribe(Bb_Mobile_OddinTreeWs_UnsubscribeResponse)
    case subscribeState(Bb_Mobile_OddinTreeWs_SubscribeStateResponse)
    case unsubscribeState(Bb_Mobile_OddinTreeWs_UnsubscribeStateRequest)
    case subscribeSport(Bb_Mobile_OddinTreeWs_SubscribeSportResponse)
    case unsubscribeSport(Bb_Mobile_OddinTreeWs_UnsubscribeSportResponse)
    case subscribeTournament(Bb_Mobile_OddinTreeWs_SubscribeTournamentResponse)
    case unsubscribeTournament(Bb_Mobile_OddinTreeWs_UnsubscribeTournamentResponse)
    case subscribeFullTournament(Bb_Mobile_OddinTreeWs_SubscribeFullTournamentResponse)
    case unsubscribeFullTournament(Bb_Mobile_OddinTreeWs_UnsubscribeFullTournamentResponse)
    case subscribeMatch(Bb_Mobile_OddinTreeWs_SubscribeMatchResponse)
    case unsubscribeMatch(Bb_Mobile_OddinTreeWs_UnsubscribeMatchResponse)
    case subscribeFullMatch(Bb_Mobile_OddinTreeWs_SubscribeFullMatchResponse)
    case unsubscribeFullMatch(Bb_Mobile_OddinTreeWs_UnsubscribeFullMatchResponse)
    case subscribeStake(Bb_Mobile_OddinTreeWs_SubscribeStakeResponse)
    case unsubscribeStake(Bb_Mobile_OddinTreeWs_UnsubscribeStakeResponse)
    case stateAwait(Bb_Mobile_OddinTreeWs_StateAwaitResponse)
    case stateReady(Bb_Mobile_OddinTreeWs_StateReadyResponse)
    case sport(Bb_Mobile_OddinTreeWs_SportResponse)
    case tournament(Bb_Mobile_OddinTreeWs_TournamentResponse)
    case match(Bb_Mobile_OddinTreeWs_MatchResponse)
    case fullMatch(Bb_Mobile_OddinTreeWs_FullMatchResponse)
    case stake(Bb_Mobile_OddinTreeWs_StakeResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Bb_Mobile_OddinTreeWs_MainResponse.OneOf_Type, rhs: Bb_Mobile_OddinTreeWs_MainResponse.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setSettings, .setSettings): return {
        guard case .setSettings(let l) = lhs, case .setSettings(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsubscribe, .unsubscribe): return {
        guard case .unsubscribe(let l) = lhs, case .unsubscribe(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeState, .subscribeState): return {
        guard case .subscribeState(let l) = lhs, case .subscribeState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsubscribeState, .unsubscribeState): return {
        guard case .unsubscribeState(let l) = lhs, case .unsubscribeState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeSport, .subscribeSport): return {
        guard case .subscribeSport(let l) = lhs, case .subscribeSport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsubscribeSport, .unsubscribeSport): return {
        guard case .unsubscribeSport(let l) = lhs, case .unsubscribeSport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeTournament, .subscribeTournament): return {
        guard case .subscribeTournament(let l) = lhs, case .subscribeTournament(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsubscribeTournament, .unsubscribeTournament): return {
        guard case .unsubscribeTournament(let l) = lhs, case .unsubscribeTournament(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeFullTournament, .subscribeFullTournament): return {
        guard case .subscribeFullTournament(let l) = lhs, case .subscribeFullTournament(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsubscribeFullTournament, .unsubscribeFullTournament): return {
        guard case .unsubscribeFullTournament(let l) = lhs, case .unsubscribeFullTournament(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeMatch, .subscribeMatch): return {
        guard case .subscribeMatch(let l) = lhs, case .subscribeMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsubscribeMatch, .unsubscribeMatch): return {
        guard case .unsubscribeMatch(let l) = lhs, case .unsubscribeMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeFullMatch, .subscribeFullMatch): return {
        guard case .subscribeFullMatch(let l) = lhs, case .subscribeFullMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsubscribeFullMatch, .unsubscribeFullMatch): return {
        guard case .unsubscribeFullMatch(let l) = lhs, case .unsubscribeFullMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeStake, .subscribeStake): return {
        guard case .subscribeStake(let l) = lhs, case .subscribeStake(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsubscribeStake, .unsubscribeStake): return {
        guard case .unsubscribeStake(let l) = lhs, case .unsubscribeStake(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stateAwait, .stateAwait): return {
        guard case .stateAwait(let l) = lhs, case .stateAwait(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stateReady, .stateReady): return {
        guard case .stateReady(let l) = lhs, case .stateReady(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sport, .sport): return {
        guard case .sport(let l) = lhs, case .sport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tournament, .tournament): return {
        guard case .tournament(let l) = lhs, case .tournament(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.match, .match): return {
        guard case .match(let l) = lhs, case .match(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fullMatch, .fullMatch): return {
        guard case .fullMatch(let l) = lhs, case .fullMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stake, .stake): return {
        guard case .stake(let l) = lhs, case .stake(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bb.mobile.oddin_tree_ws"

extension Bb_Mobile_OddinTreeWs_EmptyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EmptyRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bb_Mobile_OddinTreeWs_EmptyRequest, rhs: Bb_Mobile_OddinTreeWs_EmptyRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bb_Mobile_OddinTreeWs_DefaultResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DefaultResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "status"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 2)
    }
    if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bb_Mobile_OddinTreeWs_DefaultResponse, rhs: Bb_Mobile_OddinTreeWs_DefaultResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.status != rhs.status {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bb_Mobile_OddinTreeWs_MainRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MainRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ping"),
    2: .standard(proto: "set_settings"),
    3: .same(proto: "unsubscribe"),
    4: .standard(proto: "subscribe_state"),
    5: .standard(proto: "unsubscribe_state"),
    6: .standard(proto: "subscribe_sport"),
    7: .standard(proto: "unsubscribe_sport"),
    8: .standard(proto: "subscribe_tournament"),
    9: .standard(proto: "unsubscribe_tournament"),
    10: .standard(proto: "subscribe_full_tournament"),
    11: .standard(proto: "unsubscribe_full_tournament"),
    12: .standard(proto: "subscribe_match"),
    13: .standard(proto: "unsubscribe_match"),
    14: .standard(proto: "subscribe_full_match"),
    15: .standard(proto: "unsubscribe_full_match"),
    16: .standard(proto: "subscribe_stake"),
    17: .standard(proto: "unsubscribe_stake"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bb_Mobile_OddinTreeWs_PingRequest?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .ping(v)}
      }()
      case 2: try {
        var v: Bb_Mobile_OddinTreeWs_SetSettingsRequest?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .setSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .setSettings(v)}
      }()
      case 3: try {
        var v: Bb_Mobile_OddinTreeWs_UnsubscribeRequest?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .unsubscribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .unsubscribe(v)}
      }()
      case 4: try {
        var v: Bb_Mobile_OddinTreeWs_SubscribeStateRequest?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .subscribeState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .subscribeState(v)}
      }()
      case 5: try {
        var v: Bb_Mobile_OddinTreeWs_UnsubscribeStateRequest?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .unsubscribeState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .unsubscribeState(v)}
      }()
      case 6: try {
        var v: Bb_Mobile_OddinTreeWs_SubscribeSportRequest?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .subscribeSport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .subscribeSport(v)}
      }()
      case 7: try {
        var v: Bb_Mobile_OddinTreeWs_UnsubscribeSportRequest?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .unsubscribeSport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .unsubscribeSport(v)}
      }()
      case 8: try {
        var v: Bb_Mobile_OddinTreeWs_SubscribeTournamentRequest?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .subscribeTournament(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .subscribeTournament(v)}
      }()
      case 9: try {
        var v: Bb_Mobile_OddinTreeWs_UnsubscribeTournamentRequest?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .unsubscribeTournament(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .unsubscribeTournament(v)}
      }()
      case 10: try {
        var v: Bb_Mobile_OddinTreeWs_SubscribeFullTournamentRequest?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .subscribeFullTournament(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .subscribeFullTournament(v)}
      }()
      case 11: try {
        var v: Bb_Mobile_OddinTreeWs_UnsubscribeFullTournamentRequest?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .unsubscribeFullTournament(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .unsubscribeFullTournament(v)}
      }()
      case 12: try {
        var v: Bb_Mobile_OddinTreeWs_SubscribeMatchRequest?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .subscribeMatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .subscribeMatch(v)}
      }()
      case 13: try {
        var v: Bb_Mobile_OddinTreeWs_UnsubscribeMatchRequest?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .unsubscribeMatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .unsubscribeMatch(v)}
      }()
      case 14: try {
        var v: Bb_Mobile_OddinTreeWs_SubscribeFullMatchRequest?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .subscribeFullMatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .subscribeFullMatch(v)}
      }()
      case 15: try {
        var v: Bb_Mobile_OddinTreeWs_UnsubscribeFullMatchRequest?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .unsubscribeFullMatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .unsubscribeFullMatch(v)}
      }()
      case 16: try {
        var v: Bb_Mobile_OddinTreeWs_SubscribeStakeRequest?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .subscribeStake(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .subscribeStake(v)}
      }()
      case 17: try {
        var v: Bb_Mobile_OddinTreeWs_UnsubscribeStakeRequest?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .unsubscribeStake(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .unsubscribeStake(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.type {
    case .ping?: try {
      guard case .ping(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .setSettings?: try {
      guard case .setSettings(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .unsubscribe?: try {
      guard case .unsubscribe(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .subscribeState?: try {
      guard case .subscribeState(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .unsubscribeState?: try {
      guard case .unsubscribeState(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .subscribeSport?: try {
      guard case .subscribeSport(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .unsubscribeSport?: try {
      guard case .unsubscribeSport(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .subscribeTournament?: try {
      guard case .subscribeTournament(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .unsubscribeTournament?: try {
      guard case .unsubscribeTournament(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .subscribeFullTournament?: try {
      guard case .subscribeFullTournament(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .unsubscribeFullTournament?: try {
      guard case .unsubscribeFullTournament(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .subscribeMatch?: try {
      guard case .subscribeMatch(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .unsubscribeMatch?: try {
      guard case .unsubscribeMatch(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .subscribeFullMatch?: try {
      guard case .subscribeFullMatch(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .unsubscribeFullMatch?: try {
      guard case .unsubscribeFullMatch(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .subscribeStake?: try {
      guard case .subscribeStake(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .unsubscribeStake?: try {
      guard case .unsubscribeStake(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bb_Mobile_OddinTreeWs_MainRequest, rhs: Bb_Mobile_OddinTreeWs_MainRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bb_Mobile_OddinTreeWs_MainResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MainResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "ping"),
    3: .standard(proto: "set_settings"),
    4: .same(proto: "unsubscribe"),
    5: .standard(proto: "subscribe_state"),
    6: .standard(proto: "unsubscribe_state"),
    7: .standard(proto: "subscribe_sport"),
    8: .standard(proto: "unsubscribe_sport"),
    9: .standard(proto: "subscribe_tournament"),
    10: .standard(proto: "unsubscribe_tournament"),
    11: .standard(proto: "subscribe_full_tournament"),
    12: .standard(proto: "unsubscribe_full_tournament"),
    13: .standard(proto: "subscribe_match"),
    14: .standard(proto: "unsubscribe_match"),
    15: .standard(proto: "subscribe_full_match"),
    16: .standard(proto: "unsubscribe_full_match"),
    17: .standard(proto: "subscribe_stake"),
    18: .standard(proto: "unsubscribe_stake"),
    19: .standard(proto: "state_await"),
    20: .standard(proto: "state_ready"),
    21: .same(proto: "sport"),
    22: .same(proto: "tournament"),
    23: .same(proto: "match"),
    24: .standard(proto: "full_match"),
    25: .same(proto: "stake"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bb_Mobile_OddinTreeWs_DefaultResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .error(v)}
      }()
      case 2: try {
        var v: Bb_Mobile_OddinTreeWs_PingResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .ping(v)}
      }()
      case 3: try {
        var v: Bb_Mobile_OddinTreeWs_SetSettingsResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .setSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .setSettings(v)}
      }()
      case 4: try {
        var v: Bb_Mobile_OddinTreeWs_UnsubscribeResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .unsubscribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .unsubscribe(v)}
      }()
      case 5: try {
        var v: Bb_Mobile_OddinTreeWs_SubscribeStateResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .subscribeState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .subscribeState(v)}
      }()
      case 6: try {
        var v: Bb_Mobile_OddinTreeWs_UnsubscribeStateRequest?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .unsubscribeState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .unsubscribeState(v)}
      }()
      case 7: try {
        var v: Bb_Mobile_OddinTreeWs_SubscribeSportResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .subscribeSport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .subscribeSport(v)}
      }()
      case 8: try {
        var v: Bb_Mobile_OddinTreeWs_UnsubscribeSportResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .unsubscribeSport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .unsubscribeSport(v)}
      }()
      case 9: try {
        var v: Bb_Mobile_OddinTreeWs_SubscribeTournamentResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .subscribeTournament(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .subscribeTournament(v)}
      }()
      case 10: try {
        var v: Bb_Mobile_OddinTreeWs_UnsubscribeTournamentResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .unsubscribeTournament(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .unsubscribeTournament(v)}
      }()
      case 11: try {
        var v: Bb_Mobile_OddinTreeWs_SubscribeFullTournamentResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .subscribeFullTournament(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .subscribeFullTournament(v)}
      }()
      case 12: try {
        var v: Bb_Mobile_OddinTreeWs_UnsubscribeFullTournamentResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .unsubscribeFullTournament(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .unsubscribeFullTournament(v)}
      }()
      case 13: try {
        var v: Bb_Mobile_OddinTreeWs_SubscribeMatchResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .subscribeMatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .subscribeMatch(v)}
      }()
      case 14: try {
        var v: Bb_Mobile_OddinTreeWs_UnsubscribeMatchResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .unsubscribeMatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .unsubscribeMatch(v)}
      }()
      case 15: try {
        var v: Bb_Mobile_OddinTreeWs_SubscribeFullMatchResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .subscribeFullMatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .subscribeFullMatch(v)}
      }()
      case 16: try {
        var v: Bb_Mobile_OddinTreeWs_UnsubscribeFullMatchResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .unsubscribeFullMatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .unsubscribeFullMatch(v)}
      }()
      case 17: try {
        var v: Bb_Mobile_OddinTreeWs_SubscribeStakeResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .subscribeStake(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .subscribeStake(v)}
      }()
      case 18: try {
        var v: Bb_Mobile_OddinTreeWs_UnsubscribeStakeResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .unsubscribeStake(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .unsubscribeStake(v)}
      }()
      case 19: try {
        var v: Bb_Mobile_OddinTreeWs_StateAwaitResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .stateAwait(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .stateAwait(v)}
      }()
      case 20: try {
        var v: Bb_Mobile_OddinTreeWs_StateReadyResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .stateReady(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .stateReady(v)}
      }()
      case 21: try {
        var v: Bb_Mobile_OddinTreeWs_SportResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .sport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .sport(v)}
      }()
      case 22: try {
        var v: Bb_Mobile_OddinTreeWs_TournamentResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .tournament(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .tournament(v)}
      }()
      case 23: try {
        var v: Bb_Mobile_OddinTreeWs_MatchResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .match(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .match(v)}
      }()
      case 24: try {
        var v: Bb_Mobile_OddinTreeWs_FullMatchResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .fullMatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .fullMatch(v)}
      }()
      case 25: try {
        var v: Bb_Mobile_OddinTreeWs_StakeResponse?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .stake(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .stake(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.type {
    case .error?: try {
      guard case .error(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .setSettings?: try {
      guard case .setSettings(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .unsubscribe?: try {
      guard case .unsubscribe(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .subscribeState?: try {
      guard case .subscribeState(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .unsubscribeState?: try {
      guard case .unsubscribeState(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .subscribeSport?: try {
      guard case .subscribeSport(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .unsubscribeSport?: try {
      guard case .unsubscribeSport(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .subscribeTournament?: try {
      guard case .subscribeTournament(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .unsubscribeTournament?: try {
      guard case .unsubscribeTournament(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .subscribeFullTournament?: try {
      guard case .subscribeFullTournament(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .unsubscribeFullTournament?: try {
      guard case .unsubscribeFullTournament(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .subscribeMatch?: try {
      guard case .subscribeMatch(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .unsubscribeMatch?: try {
      guard case .unsubscribeMatch(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .subscribeFullMatch?: try {
      guard case .subscribeFullMatch(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .unsubscribeFullMatch?: try {
      guard case .unsubscribeFullMatch(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .subscribeStake?: try {
      guard case .subscribeStake(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .unsubscribeStake?: try {
      guard case .unsubscribeStake(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .stateAwait?: try {
      guard case .stateAwait(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .stateReady?: try {
      guard case .stateReady(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .sport?: try {
      guard case .sport(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .tournament?: try {
      guard case .tournament(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .match?: try {
      guard case .match(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .fullMatch?: try {
      guard case .fullMatch(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .stake?: try {
      guard case .stake(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bb_Mobile_OddinTreeWs_MainResponse, rhs: Bb_Mobile_OddinTreeWs_MainResponse) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
